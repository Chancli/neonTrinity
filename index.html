<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>Neon Orbit: Ultimate Fix</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%23000'/><circle cx='256' cy='256' r='200' stroke='%230ff' stroke-width='20' fill='none'/><circle cx='256' cy='256' r='120' stroke='%230ff' stroke-width='10' fill='none' opacity='0.5'/><circle cx='256' cy='100' r='30' fill='%230ff'/></svg>">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; touch-action: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; }
        #gameCanvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI General */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; padding-top: max(20px, env(safe-area-inset-top)); padding-bottom: max(20px, env(safe-area-inset-bottom)); z-index: 10; }
        .score-display { color: #fff; font-size: 28px; text-shadow: 0 0 10px #0ff; font-weight: bold; }
        .hints { display: flex; justify-content: space-between; width: 100%; color: rgba(0, 255, 255, 0.4); font-size: 12px; }
        
        /* Men√∫s - Z-Index alto para asegurar interacci√≥n */
        .menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; transition: opacity 0.3s; backdrop-filter: blur(8px); padding: 20px; }
        .hidden { opacity: 0; pointer-events: none; z-index: 0; }
        
        h1 { color: #0ff; font-size: 42px; margin: 0 0 10px 0; text-shadow: 0 0 20px #0ff; text-align: center; line-height: 1; }
        h1 span { color: #f05; font-size: 24px; letter-spacing: 6px; display: block; margin-top: 5px; }
        
        .status-box { width: 100%; max-width: 300px; border-left: 4px solid #0ff; background: rgba(0, 255, 255, 0.1); color: #dff; padding: 10px; margin-bottom: 15px; font-family: monospace; font-size: 12px; text-align: left; }
        
        /* Botones */
        button { background: transparent; color: #0ff; border: 2px solid #0ff; padding: 15px 30px; font-size: 18px; font-family: 'Orbitron', sans-serif; font-weight: bold; cursor: pointer; box-shadow: 0 0 15px rgba(0, 255, 255, 0.3); border-radius: 4px; text-transform: uppercase; margin-top: 10px; width: 90%; max-width: 300px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; pointer-events: auto; }
        button:active { background: #0ff; color: #000; transform: scale(0.95); }
        
        .file-btn { border-color: #f0f; color: #f0f; box-shadow: 0 0 10px rgba(255, 0, 255, 0.3); font-size: 14px; margin-bottom: 10px; }
        #fileInput { display: none; }

        /* Selector de √ìrbitas */
        .orbit-selector { display: flex; gap: 10px; margin-bottom: 20px; pointer-events: auto; }
        .orbit-btn { padding: 10px; font-size: 14px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border: 1px solid #555; color: #555; box-shadow: none; margin: 0; cursor: pointer; }
        .orbit-btn.active { border-color: #0ff; color: #0ff; box-shadow: 0 0 10px #0ff; background: rgba(0, 255, 255, 0.1); }

        .controls-guide { display: flex; gap: 20px; margin-bottom: 20px; width: 100%; max-width: 300px; }
        .c-box { border: 1px solid #333; color: #888; padding: 10px; flex: 1; text-align: center; font-size: 10px; border-radius: 4px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-layer">
        <div class="score-display">SCORE: <span id="scoreEl">0</span></div>
        <div class="hints"><span>&lt; IZQUIERDA</span><span>DERECHA &gt;</span></div>
    </div>

    <!-- MEN√ö INICIAL -->
    <div id="startMenu" class="menu-screen">
        <h1>NEON<br><span>ULTIMATE</span></h1>
        <div class="status-box" id="startMsg">SISTEMA: ONLINE.<br>Carga m√∫sica para activar reactividad.</div>
        
        <div style="color: #888; font-size: 10px; margin-bottom: 5px;">N√öMERO DE √ìRBITAS</div>
        <div class="orbit-selector">
            <button class="orbit-btn" id="orb2">2</button>
            <button class="orbit-btn active" id="orb3">3</button>
            <button class="orbit-btn" id="orb4">4</button>
        </div>

        <input type="file" id="fileInput" accept="audio/*">
        <button id="loadBtn" class="file-btn">üìÅ CARGAR MP3</button>
        <button id="startBtn">JUGAR</button>
    </div>

    <!-- MEN√ö GAME OVER -->
    <div id="gameOverMenu" class="menu-screen hidden">
        <h1 style="color: #f05; text-shadow: 0 0 20px #f05;">FIN DE<br><span style="color:#fff; font-size:20px;">PISTA</span></h1>
        <div class="status-box" style="border-color: #f05; color: #fdd;" id="overMsg">Calculando...</div>
        <div style="font-size: 20px; color: #fff; margin-bottom: 20px;">SCORE FINAL: <span id="finalScore">0</span></div>
        
        <button id="changeMusicBtn" class="file-btn" style="font-size: 12px; padding: 10px;">üéµ CAMBIAR M√öSICA</button>
        <button id="restartBtn" style="border-color: #f05; color: #f05; box-shadow: 0 0 15px #f05;">REINTENTAR</button>
    </div>

    <script>
        // Esperar a que el DOM est√© listo para asignar eventos
        document.addEventListener('DOMContentLoaded', () => {
            const canvas=document.getElementById('gameCanvas'),ctx=canvas.getContext('2d');
            const ui={
                startMenu:document.getElementById('startMenu'),gameOverMenu:document.getElementById('gameOverMenu'),
                scoreEl:document.getElementById('scoreEl'),finalScoreEl:document.getElementById('finalScore'),
                startMsg:document.getElementById('startMsg'),overMsg:document.getElementById('overMsg'),
                startBtn:document.getElementById('startBtn'),restartBtn:document.getElementById('restartBtn'),
                loadBtn:document.getElementById('loadBtn'),fileInput:document.getElementById('fileInput'),
                changeMusicBtn:document.getElementById('changeMusicBtn'),
                orbBtns: [document.getElementById('orb2'), document.getElementById('orb3'), document.getElementById('orb4')]
            };
            
            let gameState='MENU',score=0,frames=0,W,H,CX,CY;
            let laneCount = 3; // Por defecto 3
            let radii=[], baseRadii=[];
            
            const aiDb={intro:["Visualizador listo.","Selecciona tu dificultad.","Ritmo y reflejos."],win:["Sincron√≠a total."],fail:["Desincronizado."]};
            
            const AudioContext=window.AudioContext||window.webkitAudioContext;
            let actx, analyser, dataArray, musicSource, audioBuffer;
            
            let rawBass = 0;
            let kickValue = 0; 
            let beatDetected = false;
            let isMusicLoaded = false;
            let framesSinceSpawn = 0;
            let pendingSpawn = false;

            const audio={
                init:()=>{if(!actx)actx=new AudioContext();if(actx.state==='suspended')actx.resume();},
                playSfx:(f,t,d)=>{if(!actx)return;const o=actx.createOscillator(),g=actx.createGain();o.type=t;o.frequency.value=f;g.gain.value=0.1;g.gain.exponentialRampToValueAtTime(0.01,actx.currentTime+d);o.connect(g);g.connect(actx.destination);o.start();o.stop(actx.currentTime+d);},
                jump:(u)=>audio.playSfx(u?600:300,'sine',0.1),
                coin:()=>{audio.playSfx(1200,'square',0.05);setTimeout(()=>audio.playSfx(1800,'square',0.1),50);},
                crash:()=>audio.playSfx(100,'sawtooth',0.4),
                handleFileSelect: (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    audio.init();
                    ui.loadBtn.innerText = "PROCESANDO...";
                    const reader = new FileReader();
                    reader.onload = function(ev) {
                        actx.decodeAudioData(ev.target.result, function(buffer) {
                            audioBuffer = buffer;
                            isMusicLoaded = true;
                            ui.loadBtn.innerText = "‚ñ∂Ô∏è " + file.name.substring(0,15)+"...";
                            ui.loadBtn.style.borderColor = "#0f0";
                            ui.loadBtn.style.color = "#0f0";
                            ui.startBtn.innerText = "JUGAR CON M√öSICA";
                            if(gameState === 'GAMEOVER') init();
                        }, function(e){ ui.loadBtn.innerText = "ERROR AUDIO"; });
                    };
                    reader.readAsArrayBuffer(file);
                },
                startMusic: () => {
                    if (!isMusicLoaded || !audioBuffer) return;
                    if (musicSource) musicSource.stop();
                    musicSource = actx.createBufferSource();
                    musicSource.buffer = audioBuffer;
                    musicSource.loop = true;
                    analyser = actx.createAnalyser();
                    analyser.fftSize = 256; 
                    musicSource.connect(analyser);
                    analyser.connect(actx.destination);
                    musicSource.start(0);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                },
                stopMusic: () => { if (musicSource) { try { musicSource.stop(); } catch(e){} } },
                analyze: () => {
                    if (!analyser) return;
                    analyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for(let i = 0; i < 4; i++) sum += dataArray[i];
                    rawBass = sum / 4;
                    const normalizedBass = Math.max(0, (rawBass - 100) / 140);
                    if (normalizedBass > kickValue) {
                        kickValue = normalizedBass; 
                    } else {
                        kickValue *= 0.90; 
                    }
                    beatDetected = (normalizedBass > 0.75);
                }
            };

            function updateRadii() {
                W=canvas.width; H=canvas.height;
                CX=W/2; CY=H/2;
                const m = Math.min(W,H);
                baseRadii = [];
                const startR = m * 0.18;
                const space = (m * 0.45 - startR) / (laneCount - 1 || 1); 
                for(let i=0; i<laneCount; i++) {
                    baseRadii.push(startR + (i * space));
                }
                radii = [...baseRadii];
            }

            function resize(){
                canvas.width=window.innerWidth;
                canvas.height=window.innerHeight;
                updateRadii();
            }
            window.addEventListener('resize',resize);resize();

            class Player{constructor(){
                this.angle=0;
                this.lane= Math.floor(laneCount / 2); 
                this.currR=radii[this.lane];
                this.trail=[];
                this.rotationSpeed=0.04;
            }update(){
                this.rotationSpeed=0.04+(score*0.00005);
                this.angle+=this.rotationSpeed;
                const targetR = radii[this.lane];
                this.currR += (targetR - this.currR) * 0.25;
                this.x=CX+Math.cos(this.angle)*this.currR;
                this.y=CY+Math.sin(this.angle)*this.currR;
                this.trail.push({x:this.x,y:this.y});
                if(this.trail.length>12)this.trail.shift();
            }move(d){
                const old=this.lane;
                this.lane+=d;
                if(this.lane < 0) this.lane = 0;
                if(this.lane >= laneCount) this.lane = laneCount - 1;
                if(this.lane!==old)audio.jump(d>0);
            }draw(){ctx.strokeStyle='#0ff';ctx.lineWidth=4;ctx.lineCap='round';ctx.beginPath();this.trail.forEach((p,i)=>i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y));ctx.stroke();ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(this.x,this.y,6,0,Math.PI*2);ctx.fill();}}
            
            let player,obstacles=[],coins=[],particles=[],lastEnemyLane=-1;

            function init(){audio.init();if(isMusicLoaded) audio.startMusic();score=0;frames=0;framesSinceSpawn=0;lastEnemyLane=-1;ui.scoreEl.innerText=0;player=new Player();obstacles=[];coins=[];particles=[];gameState='PLAYING';ui.startMenu.classList.add('hidden');ui.gameOverMenu.classList.add('hidden');loop();}
            
            function checkSpawn(){
                const MIN_RATE = 60, START_RATE = 130;
                const targetRate = Math.max(MIN_RATE, START_RATE - Math.floor(score/2));
                framesSinceSpawn++;
                if (framesSinceSpawn > targetRate) pendingSpawn = true;
                let doSpawn = false;
                if (pendingSpawn) {
                    if (isMusicLoaded) {
                        if (beatDetected || framesSinceSpawn > targetRate + 40) doSpawn = true;
                    } else {
                        doSpawn = true;
                    }
                }
                if (doSpawn) {
                    spawnEnemy();
                    framesSinceSpawn = 0;
                    pendingSpawn = false;
                }
            }

            function spawnEnemy() {
                const TRAVEL_TIME_FRAMES = 80; 
                const travelDistance = player.rotationSpeed * TRAVEL_TIME_FRAMES;
                const targetAngle = player.angle + travelDistance;
                if(coins.some(c => Math.abs(c.angle - targetAngle) < 0.5)) return;
                let lane=Math.floor(Math.random() * laneCount); 
                if(lastEnemyLane!==-1 && laneCount > 1){
                    if(Math.random() < 0.6) {
                        while(lane === lastEnemyLane) lane=Math.floor(Math.random() * laneCount);
                    }
                }
                lastEnemyLane=lane;
                const isJumper = (score > 5) && (Math.random() < 0.25) && (laneCount > 1);
                obstacles.push({
                    angle: targetAngle,
                    lane: lane,
                    currentRadius: radii[lane],
                    active: true,
                    jumpTimer: 0,
                    isJumper: isJumper
                });
            }

            function manageCoins(){
                if(coins.length===0){
                    const spawnAngle=player.angle+(Math.PI * 1.3);
                    const lanes = Array.from({length: laneCount}, (_, i) => i).sort(()=>Math.random()-0.5);
                    for(let lane of lanes){
                        const busy=obstacles.some(o=>o.active&&Math.abs(o.angle-spawnAngle)<0.5&&o.lane===lane);
                        if(!busy){
                            coins.push({angle:spawnAngle,lane:lane,active:true});
                            break;
                        }
                    }
                }
            }
            
            function update(){
                if(gameState!=='PLAYING')return;
                frames++;
                if(isMusicLoaded) audio.analyze();
                const expansion = kickValue * 18; 
                radii = baseRadii.map(r => r + expansion);
                player.update();
                checkSpawn();
                manageCoins();
                obstacles.forEach(o => {
                    if(!o.active) return;
                    if(o.isJumper && beatDetected && isMusicLoaded && o.jumpTimer === 0){
                        if(Math.random() < 0.6){ 
                            const possibleLanes = [];
                            if(o.lane > 0) possibleLanes.push(o.lane - 1);
                            if(o.lane < laneCount - 1) possibleLanes.push(o.lane + 1);
                            const distToPlayer = Math.abs(o.angle - player.angle);
                            if(distToPlayer > 0.8 && distToPlayer < 3.0 && possibleLanes.length > 0) {
                                const newLane = possibleLanes[Math.floor(Math.random() * possibleLanes.length)];
                                const ex=CX+Math.cos(o.angle)*o.currentRadius, ey=CY+Math.sin(o.angle)*o.currentRadius;
                                createParticles(ex, ey, '#f80'); 
                                o.lane = newLane;
                                o.jumpTimer = 30;
                            }
                        }
                    }
                    if(o.jumpTimer > 0) o.jumpTimer--;
                    const targetR = radii[o.lane];
                    o.currentRadius += (targetR - o.currentRadius) * 0.4;
                });
                const SAFE_ZONE=Math.PI*2; 
                obstacles=obstacles.filter(e=>e.active&&(e.angle>player.angle-SAFE_ZONE));
                const checkHit=(e,isCoin)=>{
                    const r = isCoin ? radii[e.lane] : e.currentRadius; 
                    const ex=CX+Math.cos(e.angle)*r,ey=CY+Math.sin(e.angle)*r,dist=Math.hypot(player.x-ex,player.y-ey);
                    if(dist<20){
                        if(isCoin){
                            score+=1;ui.scoreEl.innerText=score;audio.coin();createParticles(ex,ey,'#ff0');
                            const idx=coins.indexOf(e);if(idx>-1)coins.splice(idx,1);
                        }else{
                            audio.crash();createParticles(ex,ey, e.isJumper ? '#f80' : '#f05');gameOver();e.active=false;
                        }
                    }
                };
                obstacles.forEach(o=>checkHit(o,false));coins.forEach(c=>checkHit(c,true));
                particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=0.05;});particles=particles.filter(p=>p.life>0);
            }
            
            function createParticles(x,y,color){for(let i=0;i<8;i++)particles.push({x,y,color,vx:(Math.random()-0.5)*8,vy:(Math.random()-0.5)*8,life:1});}
            
            function draw(){
                if (kickValue > 0.8 && gameState === 'PLAYING') {
                    ctx.fillStyle = 'rgba(20, 0, 30, 0.6)'; 
                } else {
                    ctx.fillStyle = '#000';
                }
                ctx.fillRect(0,0,W,H);
                
                if(isMusicLoaded) {
                    const coreSize = 15 + (kickValue * 30); 
                    const coreAlpha = 0.3 + (kickValue * 0.5);
                    const grd = ctx.createRadialGradient(CX, CY, 5, CX, CY, coreSize * 3);
                    grd.addColorStop(0, `rgba(255, 0, 255, ${coreAlpha})`);
                    grd.addColorStop(1, "rgba(0,0,0,0)");
                    ctx.fillStyle = grd;
                    ctx.beginPath(); ctx.arc(CX, CY, coreSize * 3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(CX, CY, coreSize * 0.8, 0, Math.PI*2); ctx.fill();
                }

                ctx.lineWidth=2;
                radii.forEach((r,i)=>{
                    ctx.beginPath();ctx.arc(CX,CY,r,0,Math.PI*2);
                    const glow = 0.3 + (kickValue * 0.7); 
                    ctx.strokeStyle=i===1?`rgba(0,255,255,${glow*1.5})` : `rgba(0,255,255,${glow})`;
                    ctx.shadowBlur = kickValue * 20; ctx.shadowColor = '#0ff';
                    ctx.stroke();ctx.shadowBlur = 0;
                });
                
                if(gameState==='PLAYING'){
                    coins.forEach(c=>{const r=radii[c.lane],ex=CX+Math.cos(c.angle)*r,ey=CY+Math.sin(c.angle)*r;ctx.fillStyle='#ff0';ctx.shadowBlur=15+(kickValue*20);ctx.shadowColor='#ff0';ctx.beginPath();ctx.arc(ex,ey,6+(kickValue*4),0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;});
                    
                    obstacles.forEach(o=>{if(!o.active)return;
                        const r=o.currentRadius; 
                        const ex=CX+Math.cos(o.angle)*r,ey=CY+Math.sin(o.angle)*r;
                        const baseColor = o.isJumper ? 30 : 340; 
                        const glowColor = o.isJumper ? '#f80' : '#f05';
                        const enemyGlow = 15 + (kickValue * 40);
                        ctx.fillStyle = `hsl(${baseColor}, 100%, ${60 + kickValue*20}%)`; 
                        ctx.shadowBlur = enemyGlow; ctx.shadowColor = glowColor;
                        ctx.beginPath();ctx.save();ctx.translate(ex,ey);ctx.rotate(o.angle+Math.PI/4);
                        const s = 12 + (kickValue * 8); 
                        ctx.rect(-s/2,-s/2,s,s);
                        ctx.restore();ctx.fill();ctx.shadowBlur = 0;
                    });
                    
                    ctx.shadowBlur=20;ctx.shadowColor='#0ff';player.draw();ctx.shadowBlur=0;
                    particles.forEach(p=>{ctx.fillStyle=p.color;ctx.globalAlpha=p.life;ctx.beginPath();ctx.arc(p.x,p.y,3,0,Math.PI*2);ctx.fill();});ctx.globalAlpha=1;
                }
            }
            function gameOver(){gameState='GAMEOVER';audio.stopMusic();ui.finalScoreEl.innerText=score;ui.overMsg.innerText=aiDb.fail[Math.floor(Math.random()*aiDb.fail.length)];ui.gameOverMenu.classList.remove('hidden');}
            function loop(){if(gameState==='PLAYING')requestAnimationFrame(loop);update();draw();}
            function handleInput(x){if(gameState!=='PLAYING')return; if(!isMusicLoaded) audio.init(); if(x<W/2)player.move(-1);else player.move(1);}
            
            window.addEventListener('mousedown',e=>handleInput(e.clientX));
            window.addEventListener('touchstart',e=>{if(e.target.tagName==='BUTTON'||e.target.tagName==='INPUT')return;e.preventDefault();handleInput(e.changedTouches[0].clientX);},{passive:false});
            
            // LISTENERS SEGUROS
            ui.loadBtn.addEventListener('click', (e) => { e.stopPropagation(); ui.fileInput.click(); });
            ui.fileInput.addEventListener('change', audio.handleFileSelect);
            ui.changeMusicBtn.addEventListener('click', (e) => { e.stopPropagation(); ui.fileInput.click(); });

            ui.startBtn.addEventListener('click', (e) => { e.stopPropagation(); init(); });
            ui.restartBtn.addEventListener('click', (e) => { e.stopPropagation(); init(); });
            
            // Soporte touch expl√≠cito para botones
            ui.startBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); init(); });
            ui.restartBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); init(); });
            ui.loadBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); ui.fileInput.click(); });
            ui.changeMusicBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); ui.fileInput.click(); });

            // Listeners de Selector de √ìrbita
            ui.orbBtns.forEach((btn, index) => {
                const handler = (e) => {
                    e.stopPropagation();
                    ui.orbBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    laneCount = index + 2;
                    updateRadii();
                };
                btn.addEventListener('click', handler);
                btn.addEventListener('touchstart', handler);
            });

            ui.startMsg.innerHTML="SISTEMA: ONLINE.<br>"+aiDb.intro[Math.floor(Math.random()*aiDb.intro.length)];
            // Inicializar radios
            updateRadii();
            draw();
        });
    </script>
</body>
</html>
